<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clash of Clans Upgrade Tracker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4F46E5;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-900 text-white antialiased">

<div class="container mx-auto p-4 md:p-8 max-w-4xl">
    <!-- Header -->
    <header class="text-center mb-8">
        <h1 class="text-4xl font-bold text-yellow-400 mb-2">Clash of Clans Upgrade Tracker</h1>
        <p class="text-gray-400">Upload or paste a screenshot of your "Upgrades in progress" to start tracking.</p>
    </header>

    <!-- User ID Display -->
    <div id="userInfo" class="text-center mb-6 hidden">
        <p class="text-sm text-gray-500">Your anonymous User ID: <span id="userIdDisplay" class="font-mono bg-gray-800 p-1 rounded"></span></p>
        <p class="text-xs text-gray-600 mt-1">This is used to save your timers. No personal data is stored.</p>
    </div>

    <!-- Controls Section -->
    <div class="bg-gray-800 p-6 rounded-lg shadow-lg mb-8 text-center">
        <p class="mb-4 text-gray-300">Select an uncropped screenshot for best results.</p>
        <input type="file" id="screenshotInput" accept="image/*" class="text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-600 file:text-white hover:file:bg-indigo-700 cursor-pointer">
        <p class="mt-3 text-sm text-gray-500">Or paste an image from your clipboard (Ctrl+V).</p>
        <div class="mt-4 border-t border-gray-700 pt-4">
            <button id="testNotificationBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                Add 1-Min Test Upgrade
            </button>
        </div>
        <div id="loader" class="hidden mx-auto mt-4"></div>
        <p id="loading-text" class="hidden text-indigo-400 mt-2"></p>
    </div>

    <!-- Message/Error Display -->
    <div id="messageBox" class="hidden p-4 mb-6 rounded-lg text-center"></div>

    <!-- Timers Display -->
    <div id="timersContainer" class="space-y-4">
        <!-- Timers will be dynamically inserted here -->
    </div>

</div>

<script type="module">
    // Firebase Imports
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, collection, onSnapshot, writeBatch, query, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // --- DOM Elements ---
    const screenshotInput = document.getElementById('screenshotInput');
    const testNotificationBtn = document.getElementById('testNotificationBtn');
    const timersContainer = document.getElementById('timersContainer');
    const loader = document.getElementById('loader');
    const loadingText = document.getElementById('loading-text');
    const messageBox = document.getElementById('messageBox');
    const userInfo = document.getElementById('userInfo');
    const userIdDisplay = document.getElementById('userIdDisplay');

    // --- Firebase and App State ---
    let db, auth;
    let userId;
    let timersUnsubscribe = null; // To detach the old listener
    let activeTimers = []; // Local cache of timers to manage intervals

    const appId = typeof __app_id !== 'undefined' ? __app_id : 'coc-tracker-default';
    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;

    // --- Main Initialization ---
    async function main() {
        if (!firebaseConfig) {
            showMessage('Firebase configuration is missing. The app cannot connect to the database.', 'error');
            return;
        }

        try {
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            onAuthStateChanged(auth, (user) => {
                if (user) {
                    userId = user.uid;
                    userIdDisplay.textContent = userId;
                    userInfo.classList.remove('hidden');
                    setupTimersListener();
                } else {
                    signIn();
                }
            });

        } catch (error) {
            console.error("Firebase initialization error:", error);
            showMessage('Could not initialize the application.', 'error');
        }
    }

    async function signIn() {
        try {
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                await signInWithCustomToken(auth, __initial_auth_token);
            } else {
                await signInAnonymously(auth);
            }
        } catch (error) {
            console.error("Authentication error:", error);
            showMessage('Could not authenticate with the service.', 'error');
        }
    }

    // --- Firestore Listener ---
    function setupTimersListener() {
        if (!userId) return;
        if (timersUnsubscribe) timersUnsubscribe();

        const timersCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/timers`);
        const q = query(timersCollectionRef);

        timersUnsubscribe = onSnapshot(q, (querySnapshot) => {
            activeTimers = [];
            timersContainer.innerHTML = '';
            if (querySnapshot.empty) {
                showMessage('No active upgrades found. Upload or paste a screenshot to begin.', 'info');
            } else {
                hideMessage();
            }

            querySnapshot.forEach((doc) => {
                const timerData = doc.data();
                timerData.id = doc.id;
                activeTimers.push(timerData);
            });

            activeTimers.sort((a, b) => a.endTime - b.endTime);
            activeTimers.forEach(renderTimer);

        }, (error) => {
            console.error("Error listening to timers:", error);
            showMessage('Error fetching your timers. Please refresh the page.', 'error');
        });
    }

    // --- Core Logic: Image & Data Processing ---
    async function processImageFile(file) {
        if (!file || !file.type.startsWith('image/')) {
            showMessage('Pasted content is not an image.', 'error');
            return;
        }

        if (Notification.permission === 'default') {
            Notification.requestPermission();
        }

        loader.classList.remove('hidden');
        loadingText.textContent = "Analyzing screenshot with AI...";
        loadingText.classList.remove('hidden');
        hideMessage();

        try {
            const base64ImageData = await toBase64(file);
            const parsedUpgrades = await parseImageWithGemini(base64ImageData);
            if (parsedUpgrades && parsedUpgrades.length > 0) {
                loadingText.textContent = "Saving new timers...";
                await saveUpgradesToFirestore(parsedUpgrades);
                showMessage('Successfully updated your upgrade timers!', 'success');
            } else {
                throw new Error("AI could not detect any upgrades. Please try a clearer screenshot.");
            }
        } catch (error) {
            console.error("Processing error:", error);
            showMessage(error.message, 'error');
        } finally {
            loader.classList.add('hidden');
            loadingText.classList.add('hidden');
            screenshotInput.value = '';
        }
    }

    screenshotInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
            processImageFile(file);
        }
    });

    window.addEventListener('paste', (event) => {
        const items = (event.clipboardData || event.originalEvent.clipboardData).items;
        for (const item of items) {
            if (item.type.startsWith('image/')) {
                const file = item.getAsFile();
                processImageFile(file);
                event.preventDefault();
                return;
            }
        }
    });

    testNotificationBtn.addEventListener('click', async () => {
        if (Notification.permission === 'default') {
            await Notification.requestPermission();
        }

        if(Notification.permission !== 'granted') {
            showMessage('Please enable notifications to test this feature.', 'error');
            return;
        }

        const testUpgrade = [{ building: "Test Upgrade", time: "1m" }];
        showMessage('Creating a 1-minute test upgrade...', 'info');
        await saveUpgradesToFirestore(testUpgrade);
        showMessage('Test upgrade started! You should get a notification soon.', 'success');
    });

    async function parseImageWithGemini(base64ImageData) {
        const apiKey = ""; // Leave empty
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

        const prompt = `
                Analyze this Clash of Clans screenshot showing "Upgrades in progress".
                Extract each upgrade's name and its remaining time.
                The time can be in days (d), hours (h), and minutes (m).
                Return the data as a JSON array of objects. Each object should have two keys: "building" and "time".
                For example: [{"building": "Giga Inferno", "time": "1h 36m"}, {"building": "Cannon", "time": "1d 1h"}].
                If you cannot find any upgrades, return an empty array [].
            `;

        const payload = {
            contents: [{
                role: "user",
                parts: [
                    { text: prompt },
                    { inlineData: { mimeType: "image/jpeg", data: base64ImageData.split(',')[1] } }
                ]
            }],
            generationConfig: {
                responseMimeType: "application/json",
            }
        };

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        if (!response.ok) throw new Error(`API request failed with status ${response.status}`);

        const result = await response.json();

        if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts[0]) {
            return JSON.parse(result.candidates[0].content.parts[0].text);
        } else {
            console.warn("Unexpected API response structure:", result);
            throw new Error("Could not parse the image. The AI model returned an unexpected response.");
        }
    }

    // --- Data Handling and Firestore ---
    async function saveUpgradesToFirestore(upgrades) {
        if (!userId) throw new Error("User not authenticated.");

        const batch = writeBatch(db);
        const timersCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/timers`);
        const oldDocsSnapshot = await getDocs(query(timersCollectionRef));
        oldDocsSnapshot.forEach(doc => {
            batch.delete(doc.ref);
        });

        const now = Date.now();
        upgrades.forEach(upgrade => {
            const totalSeconds = parseTime(upgrade.time);
            if (totalSeconds > 0) {
                const newTimerRef = doc(timersCollectionRef);
                batch.set(newTimerRef, {
                    buildingName: upgrade.building,
                    totalDurationInSeconds: totalSeconds,
                    endTime: now + totalSeconds * 1000,
                    notificationSent: false,
                    createdAt: now
                });
            }
        });

        await batch.commit();
    }

    // --- UI Rendering and Real-time Updates ---
    function renderTimer(timerData) {
        const timerElement = document.createElement('div');
        timerElement.className = 'bg-gray-800 p-4 rounded-lg shadow-md';
        timerElement.dataset.id = timerData.id;
        timerElement.dataset.endTime = timerData.endTime;

        timerElement.innerHTML = `
                <div class="flex justify-between items-baseline mb-2">
                    <span class="font-bold text-lg text-yellow-400">${timerData.buildingName}</span>
                    <span class="time-remaining font-mono text-gray-300"></span>
                </div>
                <p class="completion-text text-gray-400 text-sm"></p>
            `;
        timersContainer.appendChild(timerElement);

        const completionDate = new Date(timerData.endTime);
        timerElement.querySelector('.completion-text').textContent = formatCompletionTime(timerData.buildingName, completionDate);
    }

    function updateTimersUI() {
        const now = Date.now();
        document.querySelectorAll('[data-id]').forEach(timerEl => {
            const endTime = parseInt(timerEl.dataset.endTime, 10);
            const timeRemainingEl = timerEl.querySelector('.time-remaining');

            const secondsLeft = Math.round((endTime - now) / 1000);

            if (secondsLeft > 0) {
                timeRemainingEl.textContent = `( ${formatTime(secondsLeft)} left )`;

                const timerData = activeTimers.find(t => t.id === timerEl.dataset.id);
                if (timerData && !timerData.notificationSent && secondsLeft <= 120 && Notification.permission === 'granted') {
                    sendNotification(timerData);
                    timerData.notificationSent = true;
                }
            } else {
                timeRemainingEl.textContent = "( Completed! )";
                timerEl.querySelector('.font-bold').classList.add('line-through', 'text-gray-500');
            }
        });
    }

    // --- Notifications ---
    function sendNotification(timerData) {
        const body = `${timerData.buildingName} will complete in about 2 minutes.`;
        new Notification('Clash of Clans Upgrade Almost Done!', {
            body: body,
            icon: 'https://placehold.co/192x192/1F2937/FBBF24?text=CoC'
        });
    }

    // --- Utility Functions ---
    function formatCompletionTime(buildingName, date) {
        const time = date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
        const month = date.toLocaleString('en-US', { month: 'long' });

        const day = date.getDate();
        let daySuffix;
        if (day > 3 && day < 21) {
            daySuffix = 'th';
        } else {
            switch (day % 10) {
                case 1:  daySuffix = "st"; break;
                case 2:  daySuffix = "nd"; break;
                case 3:  daySuffix = "rd"; break;
                default: daySuffix = "th"; break;
            }
        }

        return `${buildingName} will be finished upgrading at ${time} on ${month} ${day}${daySuffix}.`;
    }

    function parseTime(timeStr) {
        if (!timeStr || typeof timeStr !== 'string') return 0;
        let totalSeconds = 0;
        const days = timeStr.match(/(\d+)\s*d/);
        const hours = timeStr.match(/(\d+)\s*h/);
        const minutes = timeStr.match(/(\d+)\s*m/);

        if (days) totalSeconds += parseInt(days[1]) * 86400;
        if (hours) totalSeconds += parseInt(hours[1]) * 3600;
        if (minutes) totalSeconds += parseInt(minutes[1]) * 60;

        if (!days && !hours && !minutes && timeStr.match(/(\d+)\s*s/)) {
            const seconds = timeStr.match(/(\d+)\s*s/);
            if(seconds) totalSeconds += parseInt(seconds[1]);
        }

        if(totalSeconds === 0 && /^\d+$/.test(timeStr)){
            totalSeconds += parseInt(timeStr) * 60;
        }

        return totalSeconds;
    }

    function formatTime(totalSeconds) {
        if (totalSeconds <= 0) return "0s";
        const d = Math.floor(totalSeconds / 86400);
        const h = Math.floor((totalSeconds % 86400) / 3600);
        const m = Math.floor((totalSeconds % 3600) / 60);
        const s = Math.floor(totalSeconds % 60);

        let result = '';
        if (d > 0) result += `${d}d `;
        if (h > 0) result += `${h}h `;
        if (m > 0) result += `${m}m `;
        if (s > 0 && d === 0) result += `${s}s`;
        return result.trim();
    }

    function toBase64(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = () => resolve(reader.result);
            reader.onerror = error => reject(error);
        });
    }

    function showMessage(text, type = 'info') {
        messageBox.textContent = text;
        messageBox.className = 'p-4 mb-6 rounded-lg text-center';
        const typeClasses = {
            success: 'bg-green-800 text-green-200',
            error: 'bg-red-800 text-red-200',
            info: 'bg-blue-800 text-blue-200'
        };
        messageBox.classList.add(...(typeClasses[type] || typeClasses.info).split(' '));
        messageBox.classList.remove('hidden');
    }

    function hideMessage() {
        messageBox.classList.add('hidden');
    }

    // --- Start the app ---
    main();
    setInterval(updateTimersUI, 1000);
</script>
</body>
</html>
